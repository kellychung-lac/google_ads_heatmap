<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>California Cities Heatmap</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/chroma-js@2.4.2/chroma.min.js"></script>

    <style>
      html, body, #map { height: 100%; margin: 0; }
      .control-card {
        background:#fff;
        padding:8px 10px;
        font:12px/1.2 Arial, sans-serif;
        box-shadow:0 1px 4px rgba(0,0,0,.2);
      }
      .control-card h4 { margin:4px 0 6px; font-size:12px; }
      .control-card label { display:block; cursor:pointer; margin:2px 0; }
      .legend {
        background:#fff;
        padding:6px 8px;
        line-height:1.2;
        box-shadow:0 1px 4px rgba(0,0,0,.2);
        font:12px/1.2 Arial, sans-serif;
      }
      .legend .scale {
        height:10px;
        width:220px;
        background:linear-gradient(to right,#f7fbff,#08306b);
        margin:4px 0;
      }
      .city-label {
        font-weight:600;
        font-size:12px;
        white-space:nowrap;
        text-shadow:0 1px 2px rgba(255,255,255,.9);
      }
      .inline { display:inline-block; margin-right:8px; }
      .muted { color:#666; }
      .note { margin-top:6px; font-size:11px; line-height:1.3; }

      .date-row {
        display:flex;
        gap:4px;
        align-items:center;
        margin:2px 0;
      }
      .date-row span {
        min-width:30px;
      }
      .date-row input[type="date"] {
        font-size:11px;
        padding:2px 3px;
      }
    </style>
  </head>

  <body>
    <div id="map"></div>

    <script>
      // ---------- utils ----------
      async function fetchGzipJSON(url) {
        const r = await fetch(url);
        if (!r.ok) throw new Error(`Fetch ${url}: ${r.status}`);
        const ab = await r.arrayBuffer();
        const txt = pako.ungzip(new Uint8Array(ab), { to: "string" });
        return JSON.parse(txt);
      }
      async function fetchGzipGeoOrTopoAsGeoJSON(url) {
        const obj = await fetchGzipJSON(url);
        if (obj && obj.type === "Topology") {
          const key = Object.keys(obj.objects)[0];
          return topojson.feature(obj, obj.objects[key]);
        }
        return obj;
      }
      function detectCityProp(feature) {
        const props = feature?.properties || {};
        const cands = ["CITY","City","city","NAME","Name","name","PLACENAME","PLACENAM"];
        for (const k of cands) if (k in props) return k;
        const keys = Object.keys(props);
        return keys.length ? keys[0] : "CITY";
      }
      function sampleGradient(scale, steps=16) {
        const arr = [];
        for (let i=0;i<steps;i++) {
          const t = i/(steps-1);
          arr.push(scale(t).hex());
        }
        return `linear-gradient(to right, ${arr.join(",")})`;
      }
      function ensureOrdered(a, b) {
        return a <= b ? [a, b] : [b, a];
      }

      // ---------- state ----------
      const CAMPAIGNS = ["ALL","Display","Search"];
      const EPS = 1e-9;

      // UPDATED thresholds
      const THRESHOLDS = {
        "Page views":      { minPV: 15 },
        "Form conversions": { minForms: 1 },
      };

      const state = {
        mode: "absolute", // "absolute" | "pct"

        // date ranges (as YYYY-MM-DD strings)
        dateFromAbs: null,
        dateToAbs:   null,

        dateFromA: null, // pct range A
        dateToA:   null,
        dateFromB: null, // pct range B
        dateToB:   null,

        campaign: "ALL",
        metric: "Page views",   // "Page views" | "Form conversions"

        daily: null,            // json.daily
        meta: null,             // json.meta {min_date, max_date}
        aggregatedAbs: null,    // {campaign:{city:{val_pv,val_forms,...}}} for abs range
        aggregatedFrom: null,   // same shape, pct range A
        aggregatedTo: null,     // same shape, pct range B
        pctCache: null,         // city -> {pct, from, to}

        ranges: null,           // abs: {page_views:[min,max], form_conv:[min,max]} or pct: {pct:[min,max]}
        cityProp: null,

        map: null,
        fillLayer: null,
        labelLayer: null,
        legend: null,
        showLabels: true,
        includeLA: (localStorage.getItem("includeLA") ?? "true") === "true",
      };

      function baseDir() {
        return state.includeLA ? "./data" : "./data_noLA_noSD";
      }
      function path(name, ext) {
        // ext includes suffix like "json.gz" or "geojson.gz"
        return `${baseDir()}/${name}.${ext}`;
      }

      // ---------- aggregation helpers ----------
      function aggregateRange(daily, fromStr, toStr) {
        const aggr = {};
        for (const c of CAMPAIGNS) aggr[c] = {};

        if (!daily || !fromStr || !toStr) return aggr;
        const [from, to] = ensureOrdered(fromStr, toStr);

        const dates = Object.keys(daily);
        for (const d of dates) {
          if (d < from || d > to) continue;
          const byCamp = daily[d] || {};
          for (const camp of CAMPAIGNS) {
            const cityMap = byCamp[camp] || {};
            const targetCamp = aggr[camp];
            for (const [city, rec] of Object.entries(cityMap)) {
              if (!targetCamp[city]) {
                targetCamp[city] = { val_pv: 0, val_forms: 0 };
              }
              const t = targetCamp[city];
              const pv = Number(rec.val_pv)   || 0;
              const fm = Number(rec.val_forms) || 0;
              t.val_pv   += pv;
              t.val_forms += fm;
            }
          }
        }

        // precompute log1p helpers (if you ever want them)
        for (const camp of CAMPAIGNS) {
          for (const rec of Object.values(aggr[camp])) {
            rec.val_pv_color    = Math.log1p(rec.val_pv);
            rec.val_forms_color = Math.log1p(rec.val_forms);
          }
        }

        return aggr;
      }

      function recomputeRangesAbsolute() {
        const byCity = (state.aggregatedAbs?.[state.campaign]) || {};
        let pvMin=Infinity, pvMax=-Infinity, formMin=Infinity, formMax=-Infinity;

        for (const rec of Object.values(byCity)) {
          const pv = rec?.val_pv;
          if (Number.isFinite(pv)) { pvMin = Math.min(pvMin, pv); pvMax = Math.max(pvMax, pv); }
          const fm = rec?.val_forms;
          if (Number.isFinite(fm)) { formMin = Math.min(formMin, fm); formMax = Math.max(formMax, fm); }
        }

        if (!Number.isFinite(pvMin)) pvMin = pvMax = 0;
        if (!Number.isFinite(formMin)) formMin = formMax = 0;

        state.ranges = {
          page_views: [pvMin, pvMax],
          form_conv:  [formMin, formMax],
        };
      }

      function findMinPositiveCurrent(metric) {
        const key = metric === "Page views" ? "val_pv" : "val_forms";
        const byCity = (state.aggregatedAbs?.[state.campaign]) || {};
        let m = Infinity;
        for (const rec of Object.values(byCity)) {
          const v = rec?.[key];
          if (Number.isFinite(v) && v > 0 && v < m) m = v;
        }
        return Number.isFinite(m) ? m : null;
      }

      // ---------- % difference ----------
      function computePctDiffByCity() {
        const out = {}; // city -> {pct, from, to}
        const dictFrom = state.aggregatedFrom?.[state.campaign] || {};
        const dictTo   = state.aggregatedTo?.[state.campaign]   || {};

        const cities = new Set([...Object.keys(dictFrom), ...Object.keys(dictTo)]);
        for (const city of cities) {
          const recFrom = dictFrom[city] || { val_pv: 0, val_forms: 0 };
          const recTo   = dictTo[city]   || { val_pv: 0, val_forms: 0 };

          let vFrom, vTo, passes;
          if (state.metric === "Page views") {
            vFrom = Number(recFrom.val_pv)   || 0;
            vTo   = Number(recTo.val_pv)     || 0;
            const thr = THRESHOLDS["Page views"].minPV;
            passes = vFrom >= thr && vTo >= thr;
          } else {
            vFrom = Number(recFrom.val_forms) || 0;
            vTo   = Number(recTo.val_forms)   || 0;
            const thr = THRESHOLDS["Form conversions"].minForms;
            passes = vFrom >= thr && vTo >= thr;
          }

          let pct = NaN;
          if (passes && Math.abs(vFrom) > EPS) {
            pct = ((vTo - vFrom) / Math.abs(vFrom)) * 100;
          }

          out[city] = { pct, from: vFrom, to: vTo };
        }
        return out;
      }

      function recomputeRangesPct(pctDict) {
        let min = Infinity, max = -Infinity;
        for (const { pct } of Object.values(pctDict)) {
          if (Number.isFinite(pct)) {
            if (pct < min) min = pct;
            if (pct > max) max = pct;
          }
        }
        if (!Number.isFinite(min) || !Number.isFinite(max)) { min = 0; max = 0; }
        state.ranges = { pct: [min, max] };
      }

      function getScalePct() {
        const [min, max] = state.ranges.pct;

        if (min < 0 && max > 0) {
          const scale = chroma.scale(["#67000d", "#f7f7f7", "#08306b"]).domain([min, 0, max]);
          return (pct) => (Number.isFinite(pct) ? scale(pct).hex() : "#d3d3d3");
        }
        if (max <= 0) {
          const scale = chroma.scale(["#67000d", "#f7f7f7"]).domain([min, 0]);
          return (pct) => (Number.isFinite(pct) ? scale(pct).hex() : "#d3d3d3");
        }
        const scale = chroma.scale(["#f7fbff", "#08306b"]).domain([0, max]);
        return (pct) => (Number.isFinite(pct) ? scale(pct).hex() : "#d3d3d3");
      }

      // ---------- styling / tooltips ----------
      function getScaleAbsolute(metric) {
        const [minRaw, maxRaw] =
          metric === "Page views" ? state.ranges.page_views : state.ranges.form_conv;

        const eps = 1e-9;
        const minPos = findMinPositiveCurrent(metric) || eps;
        const minForDomain = minRaw > 0 ? minRaw : minPos;
        const logMin = Math.log10(Math.max(minForDomain, eps));
        const logMax = Math.log10(Math.max(maxRaw, eps));
        const scale = chroma.scale(["#f7fbff", "#08306b"]).domain([logMin, logMax]);

        return (v) => {
          const u = (Number.isFinite(v) && v > 0) ? Math.log10(v) : NaN;
          return Number.isFinite(u) ? scale(u).hex() : "#d3d3d3";
        };
      }

      function styleFeature(feat) {
        const city = feat.properties[state.cityProp];
        if (state.mode === "absolute") {
          const rec  = (state.aggregatedAbs?.[state.campaign] || {})[city] || null;
          const v = state.metric === "Page views" ? rec?.val_pv : rec?.val_forms;
          const fill = getScaleAbsolute(state.metric)(v);
          return { color:"#000", weight:0.4, fillColor:fill, fillOpacity:Number.isFinite(v)?0.75:0.25 };
        } else {
          const info = state.pctCache?.[city] || { pct: NaN };
          const fill = getScalePct()(info.pct);
          return { color:"#000", weight:0.4, fillColor:fill, fillOpacity:Number.isFinite(info.pct)?0.75:0.25 };
        }
      }

      function formatValueAbsolute(rec) {
        if (!rec) return "—";
        const v = state.metric === "Page views" ? rec.val_pv : rec.val_forms;
        return Number.isFinite(v) ? Math.round(v).toLocaleString() : "—";
      }

      function formatValuePct(info) {
        if (!info) return "—";
        if (!Number.isFinite(info.pct)) return "—";
        const s = info.pct >= 0 ? "+" : "";
        return s + info.pct.toFixed(2) + "%";
      }

      function onEachFeature(feat, layer) {
        const city = feat.properties[state.cityProp];
        if (state.mode === "absolute") {
          const rec  = (state.aggregatedAbs?.[state.campaign] || {})[city] || null;
          layer.bindTooltip(
            `<b>${city}</b><br>${state.metric}: ${formatValueAbsolute(rec)}`,
            { sticky: true }
          );
        } else {
          const info = state.pctCache?.[city] || null;
          const val = formatValuePct(info);
          layer.bindTooltip(
            `<b>${city}</b><br>${state.metric} %Δ (A → B): ${val}`,
            { sticky: true }
          );
        }
      }

      function rebuildChoropleth() {
        if (!state.fillLayer) return;
        state.fillLayer.setStyle(styleFeature);
        state.fillLayer.eachLayer((l) => onEachFeature(l.feature, l));
      }

      // ---------- date input sync ----------
      function syncAllDateInputs() {
        const meta = state.meta || {};
        const min = meta.min_date;
        const max = meta.max_date;
        if (!min || !max) return;

        if (!state.dateFromAbs) state.dateFromAbs = min;
        if (!state.dateToAbs)   state.dateToAbs   = max;

        if (!state.dateFromA) state.dateFromA = min;
        if (!state.dateToA)   state.dateToA   = max;
        if (!state.dateFromB) state.dateFromB = min;
        if (!state.dateToB)   state.dateToB   = max;

        const setBounds = (id, val) => {
          const el = document.getElementById(id);
          if (!el) return;
          el.min = min;
          el.max = max;
          el.value = val;
        };

        setBounds("from-date-abs", state.dateFromAbs);
        setBounds("to-date-abs",   state.dateToAbs);
        setBounds("from-date-a",   state.dateFromA);
        setBounds("to-date-a",     state.dateToA);
        setBounds("from-date-b",   state.dateFromB);
        setBounds("to-date-b",     state.dateToB);
      }

      // ---------- controls ----------
      function renderTimeControlsHTML() {
        if (state.mode === "absolute") {
          return `
            <h4>Time Range</h4>
            <div class="date-row">
              <span>From</span>
              <input type="date" id="from-date-abs" name="from_date_abs" />
            </div>
            <div class="date-row">
              <span>To</span>
              <input type="date" id="to-date-abs" name="to_date_abs" />
            </div>
          `;
        } else {
          return `
            <h4>Range A (From)</h4>
            <div class="date-row">
              <span>From</span>
              <input type="date" id="from-date-a" name="from_date_a" />
            </div>
            <div class="date-row">
              <span>To</span>
              <input type="date" id="to-date-a" name="to_date_a" />
            </div>
            <h4 style="margin-top:6px;">Range B (To)</h4>
            <div class="date-row">
              <span>From</span>
              <input type="date" id="from-date-b" name="from_date_b" />
            </div>
            <div class="date-row">
              <span>To</span>
              <input type="date" id="to-date-b" name="to_date_b" />
            </div>
          `;
        }
      }

      function makeControl() {
        const Control = L.Control.extend({
          options: { position: "topright" },
          onAdd: function () {
            const div = L.DomUtil.create("div", "control-card leaflet-bar");

            let html = '';
            html += '<h4>Mode</h4>';
            html += `<label><input type="radio" name="mode" value="absolute" ${state.mode === 'absolute' ? 'checked' : ''}/> Absolute</label>`;
            html += `<label><input type="radio" name="mode" value="pct" ${state.mode === 'pct' ? 'checked' : ''}/> % Difference</label>`;
            html += '<hr/><div id="time-block">' + renderTimeControlsHTML() + '</div>';
            html += '<div id="pct-note" class="note muted" style="display:none"></div>';
            html += '<hr/>';

            html += '<h4>Campaign</h4>';
            for (const c of CAMPAIGNS) {
              html += `<label><input type="radio" name="camp" value="${c}" ${state.campaign === c ? 'checked' : ''}/> ${c}</label>`;
            }
            html += '<hr/>';

            html += '<h4>Metric</h4>';
            for (const m of ["Page views","Form conversions"]) {
              html += `<label><input type="radio" name="metric" value="${m}" ${state.metric === m ? 'checked' : ''}/> ${m}</label>`;
            }
            html += '<hr/>';

            html += '<h4>Labels</h4>';
            html += `<label><input type="checkbox" name="labels" ${state.showLabels ? 'checked' : ''}/> City Name</label>`;
            html += '<hr/>';

            html += '<h4>LA + SD</h4>';
            html += `<label><input type="radio" name="la" value="on"  ${state.includeLA ? 'checked' : ''}/> On</label>`;
            html += `<label><input type="radio" name="la" value="off" ${!state.includeLA ? 'checked' : ''}/> Off</label>`;

            div.innerHTML = html;

            function updatePctNote() {
              const el = div.querySelector('#pct-note');
              if (!el) return;
              if (state.mode === 'pct') {
                el.style.display = 'block';
                el.innerHTML = '<b>NOTE: CITY SHADING IS NEUTRAL</b><br>' +
                               'if either range has very low volume.<br>' +
                               'Page views: min 15 in each range<br>' +
                               'Form conversions: min 1 in each range.';
              } else {
                el.style.display = 'none';
                el.textContent = '';
              }
            }

            // After HTML is in place, sync any existing meta-driven dates
            syncAllDateInputs();
            updatePctNote();

            div.addEventListener("change", async (e) => {
              if (e.target.name === "mode") {
                state.mode = e.target.value;
                const tb = div.querySelector("#time-block");
                tb.innerHTML = renderTimeControlsHTML();
                syncAllDateInputs();
                updatePctNote();
                refreshComputationAndRedraw();
              }

              if (e.target.name === "camp") {
                state.campaign = e.target.value;
                refreshComputationAndRedraw();
              }

              if (e.target.name === "metric") {
                state.metric = e.target.value;
                refreshComputationAndRedraw();
              }

              if (e.target.name === "labels") {
                state.showLabels = e.target.checked;
                if (state.showLabels) updateLabels(); else clearLabels();
              }

              if (e.target.name === "la") {
                state.includeLA = e.target.value === "on";
                localStorage.setItem("includeLA", state.includeLA);
                await loadDataset();
              }

              // Date inputs
              if (e.target.name === "from_date_abs") {
                state.dateFromAbs = e.target.value || state.dateFromAbs;
                refreshComputationAndRedraw();
              }
              if (e.target.name === "to_date_abs") {
                state.dateToAbs = e.target.value || state.dateToAbs;
                refreshComputationAndRedraw();
              }
              if (e.target.name === "from_date_a") {
                state.dateFromA = e.target.value || state.dateFromA;
                refreshComputationAndRedraw();
              }
              if (e.target.name === "to_date_a") {
                state.dateToA = e.target.value || state.dateToA;
                refreshComputationAndRedraw();
              }
              if (e.target.name === "from_date_b") {
                state.dateFromB = e.target.value || state.dateFromB;
                refreshComputationAndRedraw();
              }
              if (e.target.name === "to_date_b") {
                state.dateToB = e.target.value || state.dateToB;
                refreshComputationAndRedraw();
              }
            });

            L.DomEvent.disableClickPropagation(div);
            L.DomEvent.disableScrollPropagation(div);
            return div;
          },
        });
        return new Control();
      }

      // ---------- legend ----------
      function ensureLegend() {
        if (state.legend) return;
        const Legend = L.Control.extend({
          options: { position: "bottomright" },
          onAdd: function () {
            const div = L.DomUtil.create("div", "legend leaflet-bar");
            div.innerHTML = `
              <div><b id="legend-title"></b></div>
              <div class="scale" id="legend-scale"></div>
              <div><span id="legend-min"></span> – <span id="legend-max"></span></div>
            `;
            return div;
          },
        });
        state.legend = new Legend();
        state.map.addControl(state.legend);
      }

      function updateLegend() {
        ensureLegend();
        const elTitle = document.getElementById("legend-title");
        const elMin   = document.getElementById("legend-min");
        const elMax   = document.getElementById("legend-max");
        const elScale = document.getElementById("legend-scale");

        if (state.mode === "absolute") {
          const [minRaw, maxRaw] =
            state.metric === "Page views" ? state.ranges.page_views : state.ranges.form_conv;

          let min = minRaw;
          if (min <= 0) {
            const floor = findMinPositiveCurrent(state.metric);
            if (Number.isFinite(floor)) min = floor;
          }

          elTitle.textContent = `${state.metric} (log-scaled)`;
          elMin.textContent   = Math.round(min).toLocaleString();
          elMax.textContent   = Math.round(maxRaw).toLocaleString();

          const scale = chroma.scale(["#f7fbff", "#08306b"]).domain([0,1]);
          elScale.style.background = sampleGradient(scale);
        } else {
          const [min, max] = state.ranges.pct;
          elTitle.textContent = `${state.metric} % Difference`;
          elMin.textContent   = `${min.toFixed(1)}%`;
          elMax.textContent   = `${max.toFixed(1)}%`;

          let previewScale;
          if (min < 0 && max > 0) {
            previewScale = chroma.scale(["#67000d","#f7f7f7","#08306b"]).domain([0,0.5,1]);
          } else if (max <= 0) {
            previewScale = chroma.scale(["#67000d","#f7f7f7"]).domain([0,1]);
          } else {
            previewScale = chroma.scale(["#f7fbff","#08306b"]).domain([0,1]);
          }
          elScale.style.background = sampleGradient(previewScale);
        }
      }

      // ---------- labels ----------
      let labelData = null;
      function clearLabels() {
        if (state.labelLayer) {
          state.map.removeLayer(state.labelLayer);
          state.labelLayer = null;
        }
      }
      function updateLabels() {
        if (!labelData) return;
        clearLabels();
        if (!state.showLabels) return;
        const markers = labelData.map((pt) =>
          L.marker([pt.lat, pt.lon], {
            icon: L.divIcon({ className: "", html: `<div class="city-label">${pt.city}</div>` }),
            interactive: false,
          })
        );
        state.labelLayer = L.layerGroup(markers).addTo(state.map);
        function toggleByZoom() {
          const z = state.map.getZoom();
          state.labelLayer.getLayers().forEach((m) => {
            const el = m.getElement();
            if (el) el.style.display = z >= 7 ? "block" : "none";
          });
        }
        toggleByZoom();
        state.map.off("zoomend", toggleByZoom);
        state.map.on("zoomend", toggleByZoom);
      }

      // ---------- load & refresh ----------
      async function loadDataset() {
        const json = await fetchGzipJSON(path("city_metrics", "json.gz"));
        state.daily = json.daily || {};
        state.meta  = json.meta  || {};

        syncAllDateInputs();

        // Default: compute absolute mode aggregation
        refreshComputationAndRedraw();

        const geo = await fetchGzipGeoOrTopoAsGeoJSON(path("regions", "geojson.gz"));
        state.cityProp = detectCityProp(geo.features[0]);
        if (state.fillLayer) {
          state.map.removeLayer(state.fillLayer);
          state.fillLayer = null;
        }
        state.fillLayer = L.geoJSON(geo, { style: styleFeature, onEachFeature }).addTo(state.map);

        labelData = await fetchGzipJSON(path("city_labels", "json.gz"));
        updateLabels();
        updateLegend();
        rebuildChoropleth();
      }

      function refreshComputationAndRedraw() {
        if (!state.daily || !state.meta) return;

        if (state.mode === "absolute") {
          if (!state.dateFromAbs || !state.dateToAbs) {
            state.dateFromAbs = state.meta.min_date;
            state.dateToAbs   = state.meta.max_date;
          }
          const [from, to] = ensureOrdered(state.dateFromAbs, state.dateToAbs);
          state.dateFromAbs = from;
          state.dateToAbs   = to;

          state.aggregatedAbs = aggregateRange(state.daily, from, to);
          recomputeRangesAbsolute();
        } else {
          if (!state.dateFromA || !state.dateToA) {
            state.dateFromA = state.meta.min_date;
            state.dateToA   = state.meta.max_date;
          }
          if (!state.dateFromB || !state.dateToB) {
            state.dateFromB = state.meta.min_date;
            state.dateToB   = state.meta.max_date;
          }

          let [fromA, toA] = ensureOrdered(state.dateFromA, state.dateToA);
          let [fromB, toB] = ensureOrdered(state.dateFromB, state.dateToB);
          state.dateFromA = fromA; state.dateToA = toA;
          state.dateFromB = fromB; state.dateToB = toB;

          state.aggregatedFrom = aggregateRange(state.daily, fromA, toA);
          state.aggregatedTo   = aggregateRange(state.daily, fromB, toB);
          state.pctCache       = computePctDiffByCity();
          recomputeRangesPct(state.pctCache);
        }

        syncAllDateInputs();
        updateLegend();
        rebuildChoropleth();
        updateLabels();
      }

      // ---------- init ----------
      (async function main() {
        state.map = L.map("map").setView([36.7783, -119.4179], 6);
        L.tileLayer(
          "https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}.png",
          { attribution: "&copy; OpenStreetMap contributors & Carto", maxZoom: 18 }
        ).addTo(state.map);
        state.map.addControl(makeControl());
        ensureLegend();
        await loadDataset();
      })().catch((err) => { console.error(err); alert(err.message); });
    </script>
  </body>
</html>
