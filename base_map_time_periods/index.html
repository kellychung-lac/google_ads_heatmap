<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>California Cities Heatmap</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/chroma-js@2.4.2/chroma.min.js"></script>

    <style>
      html, body, #map { height: 100%; margin: 0; }
      .control-card { background:#fff; padding:8px 10px; font:12px/1.2 Arial, sans-serif; box-shadow:0 1px 4px rgba(0,0,0,.2); }
      .control-card h4 { margin:4px 0 6px; font-size:12px; }
      .control-card label { display:block; cursor:pointer; margin:2px 0; }
      .legend { background:#fff; padding:6px 8px; line-height:1.2; box-shadow:0 1px 4px rgba(0,0,0,.2); font:12px/1.2 Arial, sans-serif; }
      .legend .scale { height:10px; width:180px; background:linear-gradient(to right,#f7fbff,#08306b); margin:4px 0; }
      .city-label { font-weight:600; font-size:12px; white-space:nowrap; text-shadow:0 1px 2px rgba(255,255,255,.9); }
    </style>
  </head>

  <body>
    <div id="map"></div>

    <script>
      async function fetchGzipJSON(url) {
        const r = await fetch(url);
        if (!r.ok) throw new Error(`Fetch ${url}: ${r.status}`);
        const ab = await r.arrayBuffer();
        const txt = pako.ungzip(new Uint8Array(ab), { to: "string" });
        return JSON.parse(txt);
      }

      async function fetchGzipGeoOrTopoAsGeoJSON(url) {
        const obj = await fetchGzipJSON(url);
        if (obj && obj.type === "Topology") {
          const key = Object.keys(obj.objects)[0];
          return topojson.feature(obj, obj.objects[key]);
        }
        return obj;
      }

      function detectCityProp(feature) {
        const props = feature?.properties || {};
        const cands = ["CITY","City","city","NAME","Name","name","PLACENAME","PLACENAM"];
        for (const k of cands) if (k in props) return k;
        const keys = Object.keys(props);
        return keys.length ? keys[0] : "CITY";
      }

      const state = {
        campaign: "ALL",
        metric: "Clicks",
        period: "all_2025",
        periods: null,
        metricsPeriod: null,
        ranges: null,
        cityProp: null,
        map: null,
        fillLayer: null,
        labelLayer: null,
        legend: null,
        showLabels: true,
        includeLA: (localStorage.getItem("includeLA") ?? "true") === "true",
      };

      function baseDir() {
        return state.includeLA ? "./data_time" : "./data_noLA_noSD_time";
      }
      function nameWithSuf(n) {
        return state.includeLA ? n : `${n}_noLA_noSD`;
      }
      function path(n, ext) {
        return `${baseDir()}/${nameWithSuf(n)}.${ext}`;
      }

      function findGlobalMinPositive(metric) {
        const key = metric === "Clicks" ? "val_clicks" : "val_conversions";
        let m = Infinity;
        for (const period of Object.values(state.periods || {})) {
          for (const camp of Object.values(period || {})) {
            for (const rec of Object.values(camp || {})) {
              const v = rec?.[key];
              if (Number.isFinite(v) && v > 0 && v < m) m = v;
            }
          }
        }
        return Number.isFinite(m) ? m : null;
      }

      function getScale(metric) {
        let [min, max] =
          metric === "CTR" ? state.ranges.ctr :
          metric === "Clicks" ? state.ranges.clicks :
          state.ranges.conversions;

        if (metric === "CTR") {
          const scale = chroma.scale(["#f7fbff", "#08306b"]).domain([min, max]);
          return (v) => (Number.isFinite(v) ? scale(v).hex() : "#d3d3d3");
        } else {
          const eps = 1e-9;
          const globalMinPos = findGlobalMinPositive(metric) || eps;
          const minForDomain = min > 0 ? min : globalMinPos;
          const logMin = Math.log10(Math.max(minForDomain, eps));
          const logMax = Math.log10(Math.max(max, eps));
          const scale = chroma.scale(["#f7fbff", "#08306b"]).domain([logMin, logMax]);
          return (v) => {
            const u = (Number.isFinite(v) && v > 0) ? Math.log10(v) : NaN;
            return Number.isFinite(u) ? scale(u).hex() : "#d3d3d3";
          };
        }
      }

      function styleFeature(feat) {
        const city = feat.properties[state.cityProp];
        const rec  = (state.metricsPeriod?.[state.campaign] || {})[city] || null;
        const v =
          state.metric === "CTR" ? rec?.val_ctr :
          state.metric === "Clicks" ? rec?.val_clicks :
          rec?.val_conversions;
        const fill = getScale(state.metric)(v);
        return { color:"#000", weight:0.4, fillColor:fill, fillOpacity:Number.isFinite(v)?0.75:0.25 };
      }

      function formatValue(rec) {
        if (!rec) return "—";
        if (state.metric === "CTR")
          return Number.isFinite(rec.val_ctr) ? (rec.val_ctr * 100).toFixed(2) + "%" : "—";
        if (state.metric === "Clicks")
          return Number.isFinite(rec.val_clicks) ? Math.round(rec.val_clicks).toLocaleString() : "—";
        return Number.isFinite(rec.val_conversions) ? Math.round(rec.val_conversions).toLocaleString() : "—";
      }

      function onEachFeature(feat, layer) {
        const city = feat.properties[state.cityProp];
        const rec  = (state.metricsPeriod?.[state.campaign] || {})[city] || null;
        layer.bindTooltip(`<b>${city}</b><br>${state.metric}: ${formatValue(rec)}`, { sticky: true });
      }

      function rebuildChoropleth() {
        if (!state.fillLayer) return;
        state.fillLayer.setStyle(styleFeature);
        state.fillLayer.eachLayer((l) => onEachFeature(l.feature, l));
      }

      function makeRadioControl() {
        const Control = L.Control.extend({
          options: { position: "topright" },
          onAdd: function () {
            const div = L.DomUtil.create("div", "control-card leaflet-bar");
            div.innerHTML = `
              <h4>Time Range</h4>
              <label><input type="radio" name="period" value="all_2025" ${state.period==="all_2025"?"checked":""}/> All 2025</label>
              <label><input type="radio" name="period" value="jan_apr_2025" ${state.period==="jan_apr_2025"?"checked":""}/> Jan–Apr 2025</label>
              <label><input type="radio" name="period" value="may_present_2025" ${state.period==="may_present_2025"?"checked":""}/> May–Present</label>
              <hr/>
              <h4>Campaign</h4>
              ${["ALL","Display","Search"].map(c=>`<label><input type="radio" name="camp" value="${c}" ${c===state.campaign?"checked":""}/> ${c}</label>`).join("")}
              <hr/>
              <h4>Metric</h4>
              ${["Clicks","CTR","Conversions"].map(m=>`<label><input type="radio" name="metric" value="${m}" ${m===state.metric?"checked":""}/> ${m}</label>`).join("")}
              <hr/>
              <h4>Labels</h4>
              <label><input type="checkbox" name="labels" ${state.showLabels ? "checked" : ""}/> City Name</label>
              <hr/>
              <h4>LA + SD</h4>
              <label><input type="radio" name="la" value="on"  ${state.includeLA ? "checked" : ""}/> On</label>
              <label><input type="radio" name="la" value="off" ${state.includeLA ? "" : "checked"}/> Off</label>
            `;
            div.addEventListener("change", async (e) => {
              if (e.target.name === "period") {
                state.period = e.target.value;
                state.metricsPeriod = state.periods?.[state.period] || {};
                rebuildChoropleth(); updateLabels();
              }
              if (e.target.name === "camp") {
                state.campaign = e.target.value;
                rebuildChoropleth(); updateLabels();
              }
              if (e.target.name === "metric") {
                state.metric = e.target.value;
                updateLegend(); rebuildChoropleth(); updateLabels();
              }
              if (e.target.name === "labels") {
                state.showLabels = e.target.checked;
                if (state.showLabels) updateLabels(); else clearLabels();
              }
              if (e.target.name === "la") {
                state.includeLA = e.target.value === "on";
                localStorage.setItem("includeLA", state.includeLA);
                await loadDataset();
              }
            });
            L.DomEvent.disableClickPropagation(div);
            L.DomEvent.disableScrollPropagation(div);
            return div;
          },
        });
        return new Control();
      }

      function ensureLegend() {
        if (state.legend) return;
        const Legend = L.Control.extend({
          options: { position: "bottomright" },
          onAdd: function () {
            const div = L.DomUtil.create("div", "legend leaflet-bar");
            div.innerHTML = `
              <div><b id="legend-title"></b></div>
              <div class="scale"></div>
              <div><span id="legend-min"></span> – <span id="legend-max"></span></div>
            `;
            return div;
          },
        });
        state.legend = new Legend();
        state.map.addControl(state.legend);
      }

      function updateLegend() {
        ensureLegend();
        let [minRaw, maxRaw] =
          state.metric === "CTR" ? state.ranges.ctr :
          state.metric === "Clicks" ? state.ranges.clicks :
          state.ranges.conversions;

        if (state.metric !== "CTR" && minRaw <= 0) {
          const floor = findGlobalMinPositive(state.metric);
          if (Number.isFinite(floor)) minRaw = floor;
        }

        document.getElementById("legend-title").textContent =
          state.metric + (state.metric === "CTR" ? "" : " (log-scaled)");
        document.getElementById("legend-min").textContent =
          state.metric === "CTR" ? (minRaw * 100).toFixed(1) + "%" : Math.round(minRaw).toLocaleString();
        document.getElementById("legend-max").textContent =
          state.metric === "CTR" ? (maxRaw * 100).toFixed(1) + "%" : Math.round(maxRaw).toLocaleString();
      }

      let labelData = null;
      function clearLabels() { if (state.labelLayer) { state.map.removeLayer(state.labelLayer); state.labelLayer = null; } }
      function updateLabels() {
        if (!labelData) return;
        clearLabels();
        if (!state.showLabels) return;
        const markers = labelData.map((pt) =>
          L.marker([pt.lat, pt.lon], {
            icon: L.divIcon({ className: "", html: `<div class="city-label">${pt.city}</div>` }),
            interactive: false,
          })
        );
        state.labelLayer = L.layerGroup(markers).addTo(state.map);
        function toggleByZoom() {
          const z = state.map.getZoom();
          state.labelLayer.getLayers().forEach((m) => (m.getElement().style.display = z >= 7 ? "block" : "none"));
        }
        toggleByZoom();
        state.map.off("zoomend", toggleByZoom);
        state.map.on("zoomend", toggleByZoom);
      }

      async function loadDataset() {
        const json = await fetchGzipJSON(path("city_metrics", "json.gz"));
        state.periods = json.periods || {};
        state.ranges  = json.ranges;
        state.metricsPeriod = state.periods[state.period] || {};

        const geo = await fetchGzipGeoOrTopoAsGeoJSON(path("regions", "geojson.gz"));
        state.cityProp = detectCityProp(geo.features[0]);
        if (state.fillLayer) { state.map.removeLayer(state.fillLayer); state.fillLayer = null; }
        state.fillLayer = L.geoJSON(geo, { style: styleFeature, onEachFeature }).addTo(state.map);

        labelData = await fetchGzipJSON(path("city_labels", "json.gz"));
        updateLabels();
        updateLegend();
        rebuildChoropleth();
      }

      (async function main() {
        state.map = L.map("map").setView([36.7783, -119.4179], 6);
        L.tileLayer("https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}.png",
          { attribution: "&copy; OpenStreetMap contributors & Carto", maxZoom: 18 }
        ).addTo(state.map);
        state.map.addControl(makeRadioControl());
        ensureLegend();
        await loadDataset();
      })().catch((err) => { console.error(err); alert(err.message); });
    </script>
  </body>
</html>
